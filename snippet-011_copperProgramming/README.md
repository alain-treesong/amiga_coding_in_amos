## Introduction

The goal of this code is to display this screen in Amos:

![AgonyLevel5](readImg/agonyLevel5Horizon.png)

This is the great background of the level 5 of the famous game Agony by Psygnosis 1992
To do this we must take control of the Copper.

### The Copper

The Copper is one of the components that makes the Amiga virtuoso compared to its time. This coprocessor in synchronization with the rendering of the image on the monitor has direct access to CHIP memory and can modify the values ​​of the Amiga's audio and video registers.

Concretely, here is a well-known example of what Copper can do:

![Shadow of the beast](readImg/shadow.png)

The image above is a dual playfield screen (see snippet 3), two fields of only 7 and 8 colors each. Copper allows you to change the value of the colors indexed according to the area of ​​the image and thus
dozens of colors are displayed simultaneously. The copper also multiplies in this example the number of sprites theoretically limited to 8 and allows the famous scrolling adding an impression of depth to the scene.

### Amos and the Copper

Amos is efficient for a BASIC because its implementation takes into account the hardware specificities of the Amiga and therefore the Copper.
For example the concept of Amos "Screens" is in fact a set of instructions generated by Amos and read by the Copper. The set of instructions that the copper reads is called a 'copper list'.
Amos' ability to open several screens simultaneously with different resolutions and a number of colors is possible because the language generates an adapted copperlist.

Here is an simple code that opens 3 screens of different resolution, height and colors displayed simultaneously in Amos:

```
Screen Open 0,320,200,32,Lowres
Screen Display 0,128,48,320,200
Print "Screen 320x200 in 32 colors"

Screen Open 1,320,32,8,Lowres
Screen Display 1,128,248,320,32
Print "Screen 320x32 in 8 specific colors"

Screen Open 2,640,64,16,$8000
Screen Display 2,128,148,640,64
Print "Screen 640x64 HIRES in 16 colors 'inside' lowres one"
```

The execution of the code gives this:

![SimpleScreens](readImg/simpleCode.png)

Doing this in 1991 in BASIC, with just a few instructions, was simply brilliant.
Note the black separating lines. They correspond to the time execution of instructions Amos placed in the copperlist to define the screen to be rendered. On such a line, all rendering is disabled (even sprites). This is a choice made by the Amos designer.

Obviously, not all the countless possibilities offered by Copper are covered by standard Amos instructions.
Here again is the image to render.

![AgonyLevel5](readImg/agonyLevel5Horizon.png)

This image is a problem for Amos because the color gradient is different between the castle and the sky, on the same line.
Amos has instructions for generating color gradients: Set Rainbow, Rainbow and Rain. It is possible to display four different "rainbows" (poetic isn(t it), but they cannot overlap.
This is a limitation of Amos but not of the Amiga. In Amos, however, you can take control of Copper and avoid this limitation.

## Programming the Copper

### First try with standard Amos

First, let's see what we can do in standard Amos.
It's easy to define a 320x256 screen and load a 2-color iff image corresponding to the castle.

![AgonyStandard](readImg/amosStandard.png)

Once the iff image has been loaded (with a single instruction !), the gradient is set up. It's pretty straightforward. The source code "castleStandard.amos" is commented.
The result is probably not too bad for the few simple instructions used.

### Taking control of Copper

To go one step further, a dedicated copper list can be written. This is perfectly compatible with the Amos language.
Several methodologies exist, described in the official Amos manual.

In this case, we propose to write the copper list ourselves, using the copper's MOVE and WAIT instructions. These instructions are placed in CHIP memory in an Amos bank and the address of this bank is supplied to a dedicated register so that the copper can read them.

To maintain the link between Amos and rendering, we use the bitplane allocation made for an Amos screen. The program therefore starts by opening a screen in the standard way and loading the image of the castle.
The difference now is that the screen is not visible (Screen Hide) and the address of the bitplane containing the castle will be set in the manual copper list.
This will enable us to use Amos functions relating to the blitter (drawing, bobs etc.) in our own copper list.

Here is the result :

![AgonyCopper](readImg/amosCastleSimple.png)

The source code "castleWithCopper.amos" is commented. Here is an additional comment for the copper list part. The copper list is written as Amos Data (classical structure in BASIC), so everything is in fact written in Amos  :
```
COPPER_LIST:
   Data $1FC,$0					' MOVE $DFF1FC,0 for AGA compatibiliy
   Data $100,$1200				' MOVE $DFF100,$1200 : 	enable bitplane 1 with register BPLCON0
   Data $102,$0					' MOVE $DFF102,$0 : no scroll with register BPLCON1
   Data $108,$0					' MOVE $DFF108/A,$0 : no modulo
   Data $10A,$0  	
_SCREEN_DISPLAY:
   Data $8E,$2C81				' MOVE $DFF08E,$2C81 : DIWSTRT
   Data $90,$2CC1				' MOVE $DFF090,$2CC1 : DIWSTOP
   Data $92,$38					' MOVE $DFF092,$38 : DDFSTRT
   Data $94,$D0					' MOVE $DFF094,$D0 : DDFSTOP
BIPLANE_PTR:
   Data $E0,BPL0HW				' MOVE $DFF0E0,BPL0HW
   Data $E2,BPL0LW				' MOVE $DFF0E2,BPL0LW
```
These data are a bit the same thing than what is done by Amos with the "Screen Open" and the "Screen Display" instructions.
DIWSTRT,DIWSTOP, DDFSTRT and DDFSTOP set a centered screen of 320x256. The video memory is set at the address of the bitplane defined with the Screen Open at the begining of the code.

Now we can add colors manipulations : 2 colors registers ($dff180 for index 0 and $dff182 for color 1) are updated  according to the ordinate on the screen.
The source is castleWithCopperEnhanced.amos.

Here is the result :

![AgonyCopper](readImg/amosCopper.png)

To understand exactly how this works, many Amiga hardware programming documentations or examples are available on the Web.
In any case, this is a basis here on which to build. That's what this snippet is all about :-)

## Going further

In addition to colors, the other hardware registers allow you to easily create classic Amiga effects such as a mirror effect. I've included one in this snippet :-)

What's interesting is that we can use the blitter instructions (screen copy, print, bob etc.) as well as the manually defined double buffer on the screen.
Perhaps this will be the subject of a future snippet.

